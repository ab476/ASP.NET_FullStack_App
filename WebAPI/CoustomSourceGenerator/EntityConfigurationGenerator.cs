using Common.Generators.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace Common.Generators;

/// <summary>
/// A Roslyn incremental source generator that scans for classes decorated with
/// <see cref="ApplyEntityConfigurationAttribute"/> and generates EF Core model builder
/// extension code to automatically apply IEntityTypeConfiguration mappings.
/// </summary>
[Generator]
public class EntityConfigurationGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Entry point for the generator. Sets up syntax providers and registers outputs.
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext generatorContext)
    {
        var classDeclarations = generatorContext.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: HasRelevantAttributes,
                transform: ExtractTargetClassInfo
            )
            .Where(static m => m is not null);

        generatorContext.RegisterSourceOutput(classDeclarations,
            static (ctx, source) => GenerateConfigurationSource(ctx, source));

        generatorContext.RegisterPostInitializationOutput(GenerateSupportingTypes);
    }
    private static readonly Dictionary<string, int> _generatedFileCounts = [];

    /// <summary>
    /// Emits EF Core configuration source for a discovered target class.
    /// </summary>
    /// <param name="generatorContext">The source production context.</param>
    /// <param name="targetClassInfo">The metadata describing the class and its mappings.</param>
    private static void GenerateConfigurationSource(SourceProductionContext generatorContext, TargetClassInfo? targetClassInfo)
    {
        if (targetClassInfo is null)
        {
            return;
        }

        var targetNamespace = targetClassInfo.NamespaceName;
        var targetClassName = targetClassInfo.ClassName;
        var generatedFileName = $"{targetNamespace}.{targetClassName}.g.cs";

        if (_generatedFileCounts.ContainsKey(generatedFileName))
        {
            _generatedFileCounts[generatedFileName]++;
        }
        else
        {
            _generatedFileCounts[generatedFileName] = 1;
        }

        var generatedConfigurationsCode = string.Join("\n",
            targetClassInfo.Configs.Select(config => $$"""
                        {
                            var config = new {{config.ConfigTypeName}}(nameRewriter);
                            config.Configure(modelBuilder.Entity<{{config.EntityTypeName}}>());
                        }
            """)
        );

        var source = $$"""
        // Generation count: {{_generatedFileCounts[generatedFileName]}}
        namespace {{targetNamespace}}
        {
            /// <summary>
            /// Aggregates and applies all <see cref="IEntityTypeConfiguration{TEntity}"/> 
            /// classes that have been registered via <c>[ApplyEntityConfiguration]</c>.
            /// </summary>
            /// <remarks>
            /// This class is generated by <c>EntityConfigurationGenerator</c> and should not 
            /// normally be edited manually. It instantiates each configuration class, passes 
            /// in the provided <see cref="INameRewriter"/> for consistent naming conventions, 
            /// and calls <see cref="IEntityTypeConfiguration{TEntity}.Configure"/> on the 
            /// appropriate <see cref="EntityTypeBuilder{TEntity}"/>.
            /// </remarks>
            partial class {{targetClassName}}
            {
                /// <summary>
                /// Applies all discovered entity type configurations to the supplied 
                /// <paramref name="modelBuilder"/>.
                /// </summary>
                /// <param name="modelBuilder">
                /// The EF Core <see cref="ModelBuilder"/> used to configure entity types 
                /// during <c>OnModelCreating</c>.
                /// </param>
                /// <param name="nameRewriter">
                /// The naming strategy service used to rewrite table and column names 
                /// (e.g., snake_case, lower_case). Passed into each configuration class 
                /// to ensure consistent naming conventions.
                /// </param>
                /// <remarks>
                /// Each configuration class (e.g., <c>TUserConfiguration</c>, 
                /// <c>TRoleConfiguration</c>) is instantiated and applied automatically.
                /// </remarks>
                public void ApplyAutoConfigurations(
                    global::Microsoft.EntityFrameworkCore.ModelBuilder modelBuilder,
                    global::EFCore.NamingConventions.Internal.INameRewriter nameRewriter
                )
                {
        {{generatedConfigurationsCode}}
                }
            }
        }
        """;

        generatorContext.AddSource(generatedFileName, source);
    }


    private const string ApplyEntityConfigurationAttribute = "ApplyEntityConfigurationAttribute";
    private const string ApplyEntityConfigurationAttributeFullName = $"Common.Generators.{ApplyEntityConfigurationAttribute}";

    /// <summary>
    /// Emits the <c>ApplyEntityConfigurationAttribute</c> attribute definition,
    /// so consumers don’t need to define it themselves.
    /// </summary>
    private static void GenerateSupportingTypes(IncrementalGeneratorPostInitializationContext context)
    {
        context.AddSource(
            hintName: $"{ApplyEntityConfigurationAttributeFullName}.g.cs",
            source: $$"""
            namespace Common.Generators
            {
                /// <summary>
                /// Apply this attribute to a partial class to indicate that it should automatically
                /// apply EF Core <see cref="IEntityTypeConfiguration{TEntity}"/> implementations.
                /// </summary>
                /// <param name="entityType">The entity type (table) to configure.</param>
                /// <param name="configType">The type that implements IEntityTypeConfiguration for the entity.</param>
                [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = true)]
                internal sealed class {{ApplyEntityConfigurationAttribute}} : System.Attribute
                {
                    public {{ApplyEntityConfigurationAttribute}}(System.Type entityType, System.Type configType)
                    {
                        EntityType = entityType;
                        ConfigType = configType;
                    }

                    public System.Type EntityType { get; }
                    public System.Type ConfigType { get; }
                }
            }
            
            """
        );
    }

    /// <summary>
    /// Extracts semantic information from a class declaration if it has the
    /// <c>ApplyEntityConfigurationAttribute</c> applied.
    /// </summary>
    private static TargetClassInfo? ExtractTargetClassInfo(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        if (context.Node is not ClassDeclarationSyntax classDeclarationSyntax)
            return null;

        if (context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
            return null;

        cancellationToken.ThrowIfCancellationRequested();

        var attributeSymbol = context.SemanticModel.Compilation
            .GetTypeByMetadataName(ApplyEntityConfigurationAttributeFullName);

        if (attributeSymbol is null)
            return null;

        cancellationToken.ThrowIfCancellationRequested();

        var configurationMappings = new List<TargetClassInfo.EntityConfigMapping>();

        foreach (var attr in classSymbol.GetAttributes())
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (!SymbolEqualityComparer.Default.Equals(attr.AttributeClass, attributeSymbol))
                continue;


            if (attr.ConstructorArguments.ElementAtOrDefault(0).Value is not INamedTypeSymbol entityType
                || attr.ConstructorArguments.ElementAtOrDefault(1).Value is not INamedTypeSymbol configType)
                continue;

            configurationMappings.Add(
                new TargetClassInfo.EntityConfigMapping(
                    entityType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                    configType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                )
            );
        }

        if (configurationMappings.Count == 0)
            return null;

        return new TargetClassInfo(
            classSymbol.ContainingNamespace.ToDisplayString(),
            classSymbol.Name,
            configurationMappings
        );
    }

    /// <summary>
    /// Checks whether the given syntax node has attributes, making it a candidate for inspection.
    /// </summary>
    private static bool HasRelevantAttributes(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        return syntaxNode is ClassDeclarationSyntax classDeclarationSyntax
            && classDeclarationSyntax.AttributeLists.Count > 0;
    }
}
